{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Income Tax Project My hobby project to self-learn Python. It computes the income tax according to Indian laws and rules. My primary focus is on learning the best practices of Python and to have fun. The income tax is of secondary focus as there are already many applications for it. :)","title":"Home"},{"location":"#income-tax-project","text":"My hobby project to self-learn Python. It computes the income tax according to Indian laws and rules. My primary focus is on learning the best practices of Python and to have fun. The income tax is of secondary focus as there are already many applications for it. :)","title":"Income Tax Project"},{"location":"docs/explanation/","text":"Explanation Placeholder, to be done later","title":"Explanation"},{"location":"docs/explanation/#explanation","text":"Placeholder, to be done later","title":"Explanation"},{"location":"docs/how-to-guides/","text":"How-To Guides Placeholder, to be done later","title":"How To Guides"},{"location":"docs/how-to-guides/#how-to-guides","text":"Placeholder, to be done later","title":"How-To Guides"},{"location":"docs/tutorials/","text":"Tutorials Placeholder, to be done later","title":"Tutorials"},{"location":"docs/tutorials/#tutorials","text":"Placeholder, to be done later","title":"Tutorials"},{"location":"reference/incometax/","text":"Namespace incometax Sub-modules incometax.tax_compute_strategy incometax.utils","title":"Index"},{"location":"reference/incometax/#namespace-incometax","text":"","title":"Namespace incometax"},{"location":"reference/incometax/#sub-modules","text":"incometax.tax_compute_strategy incometax.utils","title":"Sub-modules"},{"location":"reference/incometax/utils/","text":"Module incometax.utils Utilities for internal use of the incometax module. View Source \"\"\"Utilities for internal use of the incometax module.\"\"\" import logging import logging.config # create an instance here so it can be configured from the entry-point, # and then used everywhere. logger = logging Variables logger","title":"Utils"},{"location":"reference/incometax/utils/#module-incometaxutils","text":"Utilities for internal use of the incometax module. View Source \"\"\"Utilities for internal use of the incometax module.\"\"\" import logging import logging.config # create an instance here so it can be configured from the entry-point, # and then used everywhere. logger = logging","title":"Module incometax.utils"},{"location":"reference/incometax/utils/#variables","text":"logger","title":"Variables"},{"location":"reference/incometax/tax_compute_strategy/","text":"Module incometax.tax_compute_strategy Contains the strategy classes to compute income tax according to various options. View Source \"\"\"Contains the strategy classes to compute income tax according to various options.\"\"\" Sub-modules incometax.tax_compute_strategy.old_tax_compute_strategy","title":"Index"},{"location":"reference/incometax/tax_compute_strategy/#module-incometaxtax_compute_strategy","text":"Contains the strategy classes to compute income tax according to various options. View Source \"\"\"Contains the strategy classes to compute income tax according to various options.\"\"\"","title":"Module incometax.tax_compute_strategy"},{"location":"reference/incometax/tax_compute_strategy/#sub-modules","text":"incometax.tax_compute_strategy.old_tax_compute_strategy","title":"Sub-modules"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/","text":"Module incometax.tax_compute_strategy.old_tax_compute_strategy Strategy that computes income tax according to old tax regime. View Source \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" import math import pandas from incometax.utils import logger class OldTaxComputeStrategy : \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize data required for the computation.\"\"\" self . tax_brackets = pandas . DataFrame ( columns = [ \"Lower_Limit\" , \"Upper_Limit\" , \"Percent\" , \"Maximum_Tax\" ], data = [ # TODO: Accept this data from yaml file so user can configure it ( 0 , 2_50_000 , 0 , 0 ), ( 2_50_000 , 5_00_000 , 5 , 12_500 ), ( 5_00_000 , 10_00_000 , 20 , 1_12_500 ), ( 10_00_000 , 0 , 30 , 0 ), ], ) logger . debug ( f \"Old tax: tax brackets \\n { self . tax_brackets } \" ) def compute ( self , income ): \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary, without excluding exemptions, deductions, etc. Returns ------- tax : int Computed income tax, rounded to nearest integer. \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does. # Determine brackets whose lower limit is lower than specified income. # The highest among them will be the matching bracket. # As per Income Tax rule, only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket. In addition, the income # until the lower limit will be taxed at the rates in earlier brackets. # The filtering is done in this manner to avoid filtering two times # (once for the matching bracket, once more for the previous bracket). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try : previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError : # Special case when matching bracket is the lowest bracket. # Hence, there is no \"previous\" bracket. previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets, # which would simply be the maximum tax in the previous bracket. previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax. computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax Classes OldTaxComputeStrategy class OldTaxComputeStrategy ( ) Strategy that computes income tax according to old tax regime. View Source class OldTaxComputeStrategy: \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" def __init__ ( self ) -> None: \"\"\"Initialize data required for the computation.\"\"\" self . tax_brackets = pandas . DataFrame ( columns = [ \"Lower_Limit\" , \"Upper_Limit\" , \"Percent\" , \"Maximum_Tax\" ], data = [ # TODO: Accept this data from yaml file so user can configure it ( 0 , 2 _50_000 , 0 , 0 ), ( 2 _50_000 , 5 _00_000 , 5 , 12 _500 ), ( 5 _00_000 , 10 _00_000 , 20 , 1 _12_500 ), ( 10 _00_000 , 0 , 30 , 0 ), ], ) logger . debug ( f \"Old tax: tax brackets \\n {self.tax_brackets}\" ) def compute ( self , income ) : \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary , without excluding exemptions , deductions , etc . Returns ------- tax : int Computed income tax , rounded to nearest integer . \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does . # Determine brackets whose lower limit is lower than specified income . # The highest among them will be the matching bracket . # As per Income Tax rule , only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket . In addition , the income # until the lower limit will be taxed at the rates in earlier brackets . # The filtering is done in this manner to avoid filtering two times # ( once for the matching bracket , once more for the previous bracket ). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try: previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError: # Special case when matching bracket is the lowest bracket . # Hence , there is no \"previous\" bracket . previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets , # which would simply be the maximum tax in the previous bracket . previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax . computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax Methods compute def compute ( self , income ) Return the income tax according to old tax regime. Parameters: Name Type Description Default income int Total income from salary, without excluding exemptions, deductions, etc. None Returns: Type Description int Computed income tax, rounded to nearest integer. View Source def compute ( self , income ) : \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary , without excluding exemptions , deductions , etc . Returns ------- tax : int Computed income tax , rounded to nearest integer . \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does . # Determine brackets whose lower limit is lower than specified income . # The highest among them will be the matching bracket . # As per Income Tax rule , only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket . In addition , the income # until the lower limit will be taxed at the rates in earlier brackets . # The filtering is done in this manner to avoid filtering two times # ( once for the matching bracket , once more for the previous bracket ). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try: previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError: # Special case when matching bracket is the lowest bracket . # Hence , there is no \"previous\" bracket . previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets , # which would simply be the maximum tax in the previous bracket . previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax . computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax","title":"Old Tax Compute Strategy"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/#module-incometaxtax_compute_strategyold_tax_compute_strategy","text":"Strategy that computes income tax according to old tax regime. View Source \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" import math import pandas from incometax.utils import logger class OldTaxComputeStrategy : \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" def __init__ ( self ) -> None : \"\"\"Initialize data required for the computation.\"\"\" self . tax_brackets = pandas . DataFrame ( columns = [ \"Lower_Limit\" , \"Upper_Limit\" , \"Percent\" , \"Maximum_Tax\" ], data = [ # TODO: Accept this data from yaml file so user can configure it ( 0 , 2_50_000 , 0 , 0 ), ( 2_50_000 , 5_00_000 , 5 , 12_500 ), ( 5_00_000 , 10_00_000 , 20 , 1_12_500 ), ( 10_00_000 , 0 , 30 , 0 ), ], ) logger . debug ( f \"Old tax: tax brackets \\n { self . tax_brackets } \" ) def compute ( self , income ): \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary, without excluding exemptions, deductions, etc. Returns ------- tax : int Computed income tax, rounded to nearest integer. \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does. # Determine brackets whose lower limit is lower than specified income. # The highest among them will be the matching bracket. # As per Income Tax rule, only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket. In addition, the income # until the lower limit will be taxed at the rates in earlier brackets. # The filtering is done in this manner to avoid filtering two times # (once for the matching bracket, once more for the previous bracket). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try : previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError : # Special case when matching bracket is the lowest bracket. # Hence, there is no \"previous\" bracket. previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets, # which would simply be the maximum tax in the previous bracket. previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax. computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax","title":"Module incometax.tax_compute_strategy.old_tax_compute_strategy"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/#classes","text":"","title":"Classes"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/#oldtaxcomputestrategy","text":"class OldTaxComputeStrategy ( ) Strategy that computes income tax according to old tax regime. View Source class OldTaxComputeStrategy: \"\"\"Strategy that computes income tax according to old tax regime.\"\"\" def __init__ ( self ) -> None: \"\"\"Initialize data required for the computation.\"\"\" self . tax_brackets = pandas . DataFrame ( columns = [ \"Lower_Limit\" , \"Upper_Limit\" , \"Percent\" , \"Maximum_Tax\" ], data = [ # TODO: Accept this data from yaml file so user can configure it ( 0 , 2 _50_000 , 0 , 0 ), ( 2 _50_000 , 5 _00_000 , 5 , 12 _500 ), ( 5 _00_000 , 10 _00_000 , 20 , 1 _12_500 ), ( 10 _00_000 , 0 , 30 , 0 ), ], ) logger . debug ( f \"Old tax: tax brackets \\n {self.tax_brackets}\" ) def compute ( self , income ) : \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary , without excluding exemptions , deductions , etc . Returns ------- tax : int Computed income tax , rounded to nearest integer . \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does . # Determine brackets whose lower limit is lower than specified income . # The highest among them will be the matching bracket . # As per Income Tax rule , only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket . In addition , the income # until the lower limit will be taxed at the rates in earlier brackets . # The filtering is done in this manner to avoid filtering two times # ( once for the matching bracket , once more for the previous bracket ). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try: previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError: # Special case when matching bracket is the lowest bracket . # Hence , there is no \"previous\" bracket . previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets , # which would simply be the maximum tax in the previous bracket . previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax . computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax","title":"OldTaxComputeStrategy"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/#methods","text":"","title":"Methods"},{"location":"reference/incometax/tax_compute_strategy/old_tax_compute_strategy/#compute","text":"def compute ( self , income ) Return the income tax according to old tax regime. Parameters: Name Type Description Default income int Total income from salary, without excluding exemptions, deductions, etc. None Returns: Type Description int Computed income tax, rounded to nearest integer. View Source def compute ( self , income ) : \"\"\"Return the income tax according to old tax regime. Parameters ---------- income : int Total income from salary , without excluding exemptions , deductions , etc . Returns ------- tax : int Computed income tax , rounded to nearest integer . \"\"\" income = math . floor ( income ) # Ignore fractional part just as Income Tax website does . # Determine brackets whose lower limit is lower than specified income . # The highest among them will be the matching bracket . # As per Income Tax rule , only the income in excess of lower limit in that # bracket will be taxed at the rate of that bracket . In addition , the income # until the lower limit will be taxed at the rates in earlier brackets . # The filtering is done in this manner to avoid filtering two times # ( once for the matching bracket , once more for the previous bracket ). filtered_brackets = self . tax_brackets [ self . tax_brackets [ \"Lower_Limit\" ] < income ] matching_bracket = filtered_brackets . iloc [ - 1 ] matching_bracket_component = ( ( income - matching_bracket [ \"Lower_Limit\" ]) * matching_bracket [ \"Percent\" ] / 100 ) try: previous_bracket = filtered_brackets . iloc [ - 2 ] except IndexError: # Special case when matching bracket is the lowest bracket . # Hence , there is no \"previous\" bracket . previous_bracket_component = 0 else : # Income until lower limit is taxed according to previous brackets , # which would simply be the maximum tax in the previous bracket . previous_bracket_component = previous_bracket [ \"Maximum_Tax\" ] # Income Tax website rounds off the computed tax . computed_tax = round ( matching_bracket_component + previous_bracket_component ) return computed_tax","title":"compute"}]}